const char *fallbackShader_shadowmask_fp =
"uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform sampler2DShadow u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2DShadow u_ShadowMap2;\n"
"uniform sampler2DShadow u_ShadowMap3;\n"
"uniform sampler2DShadow u_ShadowMap4;\n"
"#endif\n"
"\n"
"uniform mat4      u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4      u_ShadowMvp2;\n"
"uniform mat4      u_ShadowMvp3;\n"
"uniform mat4      u_ShadowMvp4;\n"
"#endif\n"
"\n"
"uniform vec3   u_ViewOrigin;\n"
"uniform vec4   u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"varying vec2   var_DepthTex;\n"
"varying vec3   var_ViewDir;\n"
"\n"
"// depth is GL_DEPTH_COMPONENT24\n"
"// so the maximum error is 1.0 / 2^24\n"
"#define DEPTH_MAX_ERROR 0.000000059604644775390625\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"float PCF(const sampler2DShadow shadowmap, const vec2 st, const float dist)\n"
"{\n"
"	float mult;\n"
"	float scale = 2.0 / r_shadowMapSize;\n"
"\n"
"#if 0\n"
"	// from http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html\n"
"	vec2 offset = vec2(greaterThan(fract(var_DepthTex.xy * r_FBufScale * 0.5), vec2(0.25)));\n"
"	offset.y += offset.x;\n"
"	if (offset.y > 1.1) offset.y = 0.0;\n"
"	\n"
"	mult = shadow2D(shadowmap, vec3(st + (offset + vec2(-1.5,  0.5)) * scale, dist))\n"
"	     + shadow2D(shadowmap, vec3(st + (offset + vec2( 0.5,  0.5)) * scale, dist))\n"
"	     + shadow2D(shadowmap, vec3(st + (offset + vec2(-1.5, -1.5)) * scale, dist))\n"
"	     + shadow2D(shadowmap, vec3(st + (offset + vec2( 0.5, -1.5)) * scale, dist));\n"
"	 \n"
"	mult *= 0.25;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOW_FILTER)\n"
"	float r = random(var_DepthTex.xy);\n"
"	float sinr = sin(r) * scale;\n"
"	float cosr = cos(r) * scale;\n"
"	mat2 rmat = mat2(cosr, sinr, -sinr, cosr);\n"
"\n"
"	mult =  shadow2D(shadowmap, vec3(st + rmat * vec2(-0.7055767, 0.196515), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(0.3524343, -0.7791386), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(0.2391056, 0.9189604), dist));\n"
"  #if defined(USE_SHADOW_FILTER2)\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(-0.07580382, -0.09224417), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(0.5784913, -0.002528916), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(0.192888, 0.4064181), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(-0.6335801, -0.5247476), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(-0.5579782, 0.7491854), dist));\n"
"	mult += shadow2D(shadowmap, vec3(st + rmat * vec2(0.7320465, 0.6317794), dist));\n"
"\n"
"	mult *= 0.11111;\n"
"  #else\n"
"    mult *= 0.33333;\n"
"  #endif\n"
"#else\n"
"	mult = shadow2D(shadowmap, vec3(st, dist));\n"
"#endif\n"
"\n"
"	return mult;\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture2D(depthMap, tex).r - DEPTH_MAX_ERROR;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float result;\n"
"\n"
"	float depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);\n"
"	vec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * (depth - 0.5 / u_ViewInfo.x), 1.0);\n"
"\n"
"	vec4 shadowpos = u_ShadowMvp * biasPos;\n"
"\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"	{\n"
"#endif\n"
"		shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"		result = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	}\n"
"	else\n"
"	{\n"
"		shadowpos = u_ShadowMvp2 * biasPos;\n"
"\n"
"		if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"		{\n"
"			shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"			result = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\n"
"		}\n"
"		else\n"
"		{\n"
"			shadowpos = u_ShadowMvp3 * biasPos;\n"
"\n"
"			if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"			{\n"
"				shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"				result = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\n"
"			}\n"
"			else\n"
"			{\n"
"				shadowpos = u_ShadowMvp4 * biasPos;\n"
"				shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"				result = PCF(u_ShadowMap4, shadowpos.xy, shadowpos.z);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"\n"
"	gl_FragColor = vec4(vec3(result), 1.0);\n"
"}\n"
;
